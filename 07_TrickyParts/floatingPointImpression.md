컴퓨터의 숫자는 이진법으로 저장되는데, 소수도 마찬가지이다
인간이 쓰는 십진소수점을 먼저 보자.
0.1을 10개 가져오면 자릿수가 올라가고 1.0이 된다.

이진소수법은 0.1을 2개 가져오면 자릿수가 올라가고 1.0이 된다.
그렇다면 0.1(2)는 0.5(10)이겠다.

십진소수법에서 유한소수점을 살펴볼 때,
0.2 = 0.1 * 2
0.45 = 0.05 * 9
처럼 십진유한소수는 수를 10으로 쪼개나가다보면 나누어 떨어진다는 것
→ 분모에 알맞은 수를 곱하면 10의 거듭제곱으로 표현할 수 있다.

십진무한소수는 수를 10으로 아무리 쪼개도 완벽하게 나누어지지 않는다.
1/3

이진법도 유한소수, 무한소수가 있다.
2로 계속 나누다가 완벽히 떨어지면 유한, 아니면 무한이다.
<유한>
0.5(10) → 0.1(2)
0.625(10) → 0.101(2)

반대로 <무한>도 있을 것
0.33333(10) → 0.011011000...(2)
0.1(10)도 이진무한소수이다. 0.0001101...(2)
왜냐면 1/10의 분모 10에 어떤 적당한 수를 곱한다고 해도 2의 거듭제곱으로 표현할 수는 없기 때문이다.

메모리는 유한하기떄문에 무한소수를 전부 저장할 수는 없다.
float면 32비트, sign(부호), 지수(exp), 소수 23비트 중 소수에 이 무한소수를 23만큼 저장하고, 나머지 대상을 삭제한다.

이 잘려진 무한2진소수는
0.000110011001100110011001101(2) -> 0.1000000149011611938(10)이다.

사람에게 보여줄 때는 10진법으로 보여주고, 반올림하여 0.1이 된다.
근데 유효숫자를 올려버리면 바로 tailing이 생기게 되지.

0.1 * 0.1은 float에서는 0.01이 아니라 0.0099와 가장 가깝기에
0.1*0.1 !== 0.01이 되는 것이다.